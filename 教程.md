# 教程

## 在我们开始之前

欢迎来到 Formik 教程。这将教会你在 React 中构建简单和复杂表单所需的一切。

如果你没有耐心，只想在你的机器上开始完成工作，请查看 [60 秒的快速入门](https://formik.org/docs/tutorial#installation)。

### 我们在建造什么？

在本教程中，我们将用 React 和 Formik 构建一个复杂的通讯注册表。

你可以在这里看到我们要建造的东西：[最终结果](https://codesandbox.io/s/formik-v2-tutorial-final-ge1pt)。如果这些代码对你来说没有意义，不要担心！本教程的目的是帮助你了解 Formik。

### 先决条件

你需要熟悉 HTML、CSS、[现代 JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript) 和 [React](https://reactjs.org/)（以及 [React Hooks](https://reactjs.org/docs/hooks-intro.html)），才能完全理解 Formik 和它的工作方式。在本教程中，我们将使用[箭头函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)、[let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)、[const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const)、[spread 语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)、[重构](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)、[计算属性名](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names)和 [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) 。你可以使用 [Babel REPL](https://babeljs.io/repl/#?presets=react&code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA) 来检查 ES6 代码的编译结果。

## 教程的设置

有两种方法可以完成本教程：你可以在浏览器中编写代码，或者在电脑上建立一个本地开发环境。

### 设置方案 1：在浏览器中编写代码

这是最快速的方法，可以开始了!

首先，在一个新标签页中打开这个[启动代码](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr)。新标签应该显示一个电子邮件地址输入，一个提交按钮，以及一些 React 代码。我们将在本教程中编辑 React 代码。

跳过第二个设置选项，进入[概览](#概述什么是-formik)部分，了解 Formik 的概况。

### 设置方案 2：本地开发环境

这完全是可有可无的，对本教程来说不是必须的!

可选：使用你喜欢的文本编辑器在本地进行跟踪的说明

这种设置需要更多的工作，但允许你使用你选择的编辑器来完成教程。以下是需要遵循的步骤。

1. 确保你安装了最新版本的 [Node.js](https://nodejs.org/en/)。
2. 按照 [Create React App 的安装说明](https://create-react-app.dev/)，制作一个新项目。

```powershell
npx create-react-app my-app
```

1. 安装 Formik

```powershell
npm i formik
```

或

```powershell
yarn add formik
```

1. 删除新项目 `src/` 文件夹中的所有文件

> 请注意：
>
> **不要删除整个 `src` 文件夹，只删除里面的原始源文件。**我们将在下一步用这个项目的例子来替换默认的源文件。

```powershell
cd my-app
cd src

# 如果你使用的是 Mac 或 Linux：
rm -f *

# 或者，如果你是在 Windows 上：
del *

# 然后，切换回项目文件夹
cd ..
```

5. 在 `src/` 文件夹中添加一个名为 `style.css` 的文件，其中包含[该 CSS 代码](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr?file=/src/styles.css)。
6. 在 `src/` 文件夹中添加一个名为 `index.js` 的文件，其中包含[该 JS 代码](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr?file=/src/index.js:0-759)。

现在在项目文件夹中运行 `npm start`，在浏览器中打开 `http://localhost:3000`。你应该看到一个电子邮件输入和一个提交按钮。

我们建议按照[这些说明](https://babeljs.io/docs/editors/)来为你的编辑器配置语法高亮。

### 帮助，我被卡住了!

如果你被卡住了，请查看 Formik 的 [GitHub 讨论](https://github.com/formik/formik/discussions)。此外，[Formium 社区的 Discord 服务](https://discord.gg/pJSg287)也是一个快速获得帮助的好方法。如果你没有收到答案，或者你仍然被卡住，请提交一个问题，我们会帮助你解决。

## 概述：什么是 Formik？

Formik 是一小群 React 组件和 hook，用于在 React 和 React Native 中构建表单。它有助于解决三个最恼人的部分：

1. 在表格状态中获取数值和退出表格状态
2. 验证和错误信息
3. 处理表单提交

通过将上述所有内容集中在一个地方，Formik 使事情变得井井有条——使测试、重构和推理你的表单变得轻而易举。

## 基础知识

我们将从使用 Formik 的最详细的方式开始。虽然这看起来有点啰嗦，但重要的是要看到 Formik 是如何建立在自己身上的，这样你就能充分掌握什么是可能的，并对它的工作方式有一个完整的心理模型。

### 一个简单的通讯注册表

想象一下，我们想为一个博客添加一个通讯注册表格。首先，我们的表单将只有一个名为 `email` 的字段。使用 Formik，这只是几行代码而已。

```js
import React from 'react'
import { useFormik } from 'formik'

const SignupForm = () => {
  // 传递 useFormik() hook 的初始表单值和一个提交函数，当表单被提交时将被调用
  const formik = useFormik({
    initialValues: {
      email: '',
    },
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        value={formik.values.email}
      />

      <button type='submit'>Submit</button>
    </form>
  )
}
```

我们把表单的 `initialValues` 和一个提交函数（`onSubmit`）传递给 `useFormik()` 挂钩。然后，hook 将表单状态和辅助方法的一个好东西包返回给我们，我们称之为 `formik`。现在，我们唯一关心的辅助方法如下：

- `handleSubmit`：一个提交处理程序
- `handleChange`：传递给每个 `<input>`、`<select>` 或 `<textarea>` 的变更处理程序。
- `values`：我们表格的当前值

正如你在上面看到的，我们把这些东西分别传递给它们各自的 props……就这样了现在我们可以拥有一个由 Formik 驱动的工作表单。我们不需要自己管理表单的值，也不需要为每一个输入编写自己的自定义事件处理程序，我们只需要使用 `useFormik()`。

这很整洁，但只有一个输入，使用 `useFormik()` 的好处就不清楚了。所以我们再增加两个输入：一个是用户的名字和姓氏，我们将其作为 `firstName` 和 `lastName` 存储在表单中。

```js
import React from 'react'
import { useFormik } from 'formik'

const SignupForm = () => {
  // 请注意，我们必须用值来初始化所有的字段。这些值可以来自 props，但因为我们不想预填这个表单，所以我们只使用一个空字符串。如果我们不这样做，React 会警告我们。
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        name='firstName'
        type='text'
        onChange={formik.handleChange}
        value={formik.values.firstName}
      />

      <label htmlFor='lastName'>Last Name</label>
      <input
        id='lastName'
        name='lastName'
        type='text'
        onChange={formik.handleChange}
        value={formik.values.lastName}
      />

      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        value={formik.values.email}
      />

      <button type='submit'>Submit</button>
    </form>
  )
}
```

如果你仔细看一下我们的新代码，你会发现一些模式和对称性的形成。

1. 我们为每个 HTML 输入重复使用完全相同的变化处理函数 `handleChange`。
2. 我们传递一个 `id` 和 `name` 的 HTML 属性，与我们在 `initialValues` 中定义的属性匹配。
3. 我们使用相同的名称访问字段的值（`email` -> `formik.values.email`）。

如果你熟悉用普通 React 构建表单，你可以认为 Formik 的`handleChange`是这样工作的：

```js
 const [values, setValues] = React.useState({});

 const handleChange = event => {
   setValues(prevValues => ({
     ...prevValues,
     // 我们用名字来告诉 Formik 要更新`values`中的哪个键。
     [event.target.name]: event.target.value
   });
 }
```

## 审定

虽然我们的联系表可以工作，但它的功能并不完整；用户可以提交它，但它没有告诉他们哪些（如果有的话）字段是必须的。

如果我们同意使用浏览器内置的 HTML 输入验证，我们可以为每个输入添加一个 `required` 参数，指定最小/最大长度（`maxlength` 和 `minlength`），和/或为每个输入添加一个 `pattern` 参数进行重码验证。如果我们能做到的话，这些都很好。然而，HTML 验证有其局限性。首先，它只在浏览器中工作所以这对 React Native 来说显然是不可行的。第二，它很难/不可能向我们的用户显示自定义错误信息。第三，它是非常粗糙的。

如前所述，Formik 不仅跟踪你的表单的 `values`，而且还跟踪它的验证和错误信息。为了用 JS 添加验证，让我们指定一个自定义验证函数，并将其作为 `validate` 传递给 `useFormik()` hook。如果存在错误，这个自定义验证函数应该产生一个 `error` 对象，其形状与我们的 `values`/`initialValues` 匹配。再次……_对称……是的……_

```js
import React from 'react'
import { useFormik } from 'formik'

// 一个自定义的验证函数。这必须返回一个对象，其键值与我们的值/初始值对称。
const validate = values => {
  const errors = {}
  if (!values.firstName) {
    errors.firstName = 'Required'
  } else if (values.firstName.length > 15) {
    errors.firstName = 'Must be 15 characters or less'
  }

  if (!values.lastName) {
    errors.lastName = 'Required'
  } else if (values.lastName.length > 20) {
    errors.lastName = 'Must be 20 characters or less'
  }

  if (!values.email) {
    errors.email = 'Required'
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
    errors.email = 'Invalid email address'
  }

  return errors
}

const SignupForm = () => {
  // 传递 useFormik() hook 的初始表单值，一个验证函数，当表单值改变或字段模糊时将被调用，以及一个提交函数，当表单被提交时将被调用。
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validate,
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        name='firstName'
        type='text'
        onChange={formik.handleChange}
        value={formik.values.firstName}
      />
      {formik.errors.firstName ? <div>{formik.errors.firstName}</div> : null}

      <label htmlFor='lastName'>Last Name</label>
      <input
        id='lastName'
        name='lastName'
        type='text'
        onChange={formik.handleChange}
        value={formik.values.lastName}
      />
      {formik.errors.lastName ? <div>{formik.errors.lastName}</div> : null}

      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        value={formik.values.email}
      />
      {formik.errors.email ? <div>{formik.errors.email}</div> : null}

      <button type='submit'>Submit</button>
    </form>
  )
}
```

`formik.errors` 是通过自定义验证函数填充的。默认情况下，Formik 会在每个按键（变化事件）、每个输入的[模糊事件](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event)以及提交之前进行验证。我们传递给 `useFormik()` 的 `onSubmit` 函数只有在没有错误的情况下才会被执行（也就是说，如果我们的 `validate` 函数返回 `{}`）。

## 访问过的领域

虽然我们的表单可以工作，而且我们的用户可以看到每个错误，但这对他们来说不是一个好的用户体验。由于我们的验证功能是针对整个表单的 `values` 在每个按键上运行的，我们的 `errors` 对象包含了任何时候的所有验证错误。在我们的组件中，我们只是检查错误是否存在，然后立即将其显示给用户。这是很尴尬的，因为我们要显示用户还没有访问过的字段的错误信息。大多数情况下，我们只想在用户完成输入后显示该字段的错误信息。

像 `errors` 和 `values` 一样，Formik 跟踪哪些字段被访问过。它将这些信息存储在一个叫做 `touched` 的对象中，它也反映了 `values`/`initialValues` 的形状。`touched` 的键是字段名，`touched` 的值是布尔值 `true`/`false`。

为了利用 `touched`，我们将 `formik.handleBlur` 传递给每个输入的 `onBlur` 参数。这个函数的工作原理与 `formik.handleChange` 类似，它使用 `name` 属性来确定要更新的字段。

```js
import React from 'react'
import { useFormik } from 'formik'

const validate = values => {
  const errors = {}

  if (!values.firstName) {
    errors.firstName = 'Required'
  } else if (values.firstName.length > 15) {
    errors.firstName = 'Must be 15 characters or less'
  }

  if (!values.lastName) {
    errors.lastName = 'Required'
  } else if (values.lastName.length > 20) {
    errors.lastName = 'Must be 20 characters or less'
  }

  if (!values.email) {
    errors.email = 'Required'
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
    errors.email = 'Invalid email address'
  }

  return errors
}

const SignupForm = () => {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validate,
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        name='firstName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.firstName}
      />
      {formik.errors.firstName ? <div>{formik.errors.firstName}</div> : null}

      <label htmlFor='lastName'>Last Name</label>
      <input
        id='lastName'
        name='lastName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.lastName}
      />
      {formik.errors.lastName ? <div>{formik.errors.lastName}</div> : null}

      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.email}
      />
      {formik.errors.email ? <div>{formik.errors.email}</div> : null}

      <button type='submit'>Submit</button>
    </form>
  )
}
```

差不多了!现在我们正在追踪 `touched`，我们现在可以改变我们的错误信息渲染逻辑，*只*显示一个给定字段的错误信息，如果它存在*并且*我们的用户已经访问了该字段。

```js
import React from 'react'
import { useFormik } from 'formik'

const validate = values => {
  const errors = {}

  if (!values.firstName) {
    errors.firstName = 'Required'
  } else if (values.firstName.length > 15) {
    errors.firstName = 'Must be 15 characters or less'
  }

  if (!values.lastName) {
    errors.lastName = 'Required'
  } else if (values.lastName.length > 20) {
    errors.lastName = 'Must be 20 characters or less'
  }

  if (!values.email) {
    errors.email = 'Required'
  } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.test(values.email)) {
    errors.email = 'Invalid email address'
  }

  return errors
}

const SignupForm = () => {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validate,
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        name='firstName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.firstName}
      />
      {formik.touched.firstName && formik.errors.firstName ? (
        <div>{formik.errors.firstName}</div>
      ) : null}

      <label htmlFor='lastName'>Last Name</label>
      <input
        id='lastName'
        name='lastName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.lastName}
      />
      {formik.touched.lastName && formik.errors.lastName ? (
        <div>{formik.errors.lastName}</div>
      ) : null}

      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.email}
      />
      {formik.touched.email && formik.errors.email ? (
        <div>{formik.errors.email}</div>
      ) : null}

      <button type='submit'>Submit</button>
    </form>
  )
}
```

### 用 Yup 进行模式验证

正如你在上面看到的，验证由你决定。你可以自由地编写你自己的验证器或使用第三方的辅助库。Formik 的作者/很大一部分用户使用 [Jason Quense](https://github.com/jquense) 的库 [Yup](https://github.com/jquense/yup) 进行对象模式验证。Yup 有一个类似于 [Joi](https://github.com/hapijs/joi) 和 [React PropTypes](https://github.com/facebook/prop-types) 的 API，但对于浏览器来说也足够小，对于运行时使用来说也足够快。你可以在这里用这个 [REPL](https://runkit.com/jquense/yup) 试试。

由于 Formik 作者/用户非常*喜欢* Yup，Formik 为 Yup 提供了一个特殊的配置参数，叫做 `validationSchema`，它将自动把 Yup 的验证错误信息转化为一个漂亮的对象，其键值与 `values`/`initialValues`/`touched` 相匹配（就像任何自定义验证函数都必须这样）。总之，你可以从 NPM/yarn 安装 Yup，像这样……

```powershell
 npm install yup --save

 # 或通过 yarn

 yarn add yup
```

为了看看 Yup 是如何工作的，让我们去掉我们的自定义验证函数 `validate`，用 Yup 和 `validationSchema` 重新写我们的验证。

```js
import React from 'react'
import { useFormik } from 'formik'
import * as Yup from 'yup'

const SignupForm = () => {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validationSchema: Yup.object({
      firstName: Yup.string()
        .max(15, 'Must be 15 characters or less')
        .required('Required'),
      lastName: Yup.string()
        .max(20, 'Must be 20 characters or less')
        .required('Required'),
      email: Yup.string().email('Invalid email address').required('Required'),
    }),
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        name='firstName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.firstName}
      />
      {formik.touched.firstName && formik.errors.firstName ? (
        <div>{formik.errors.firstName}</div>
      ) : null}

      <label htmlFor='lastName'>Last Name</label>
      <input
        id='lastName'
        name='lastName'
        type='text'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.lastName}
      />
      {formik.touched.lastName && formik.errors.lastName ? (
        <div>{formik.errors.lastName}</div>
      ) : null}

      <label htmlFor='email'>Email Address</label>
      <input
        id='email'
        name='email'
        type='email'
        onChange={formik.handleChange}
        onBlur={formik.handleBlur}
        value={formik.values.email}
      />
      {formik.touched.email && formik.errors.email ? (
        <div>{formik.errors.email}</div>
      ) : null}

      <button type='submit'>Submit</button>
    </form>
  )
}
```

同样，Yup 是 100% 可选的。然而，我们建议试一试。正如你在上面看到的，我们只用 10 行代码就表达了完全相同的验证功能，而不是 30 行。Formik 的核心设计原则之一是帮助你保持有序。Yup 在这方面肯定有很大帮助--hemas 是非常有表现力的，直观的（因为它们反映了你的价值），而且可以重复使用。无论你是否使用 Yup，我们强烈建议你在你的应用程序中共享常用的验证方法。这将确保常见的字段（如电子邮件、街道地址、用户名、电话号码等）得到一致的验证，从而获得更好的用户体验。

## 减少模板

### getFieldProps()

上面的代码非常明确地说明了 Formik 到底在做什么。`onChange` -> `handleChange`, `onBlur` -> `handleBlur`, 等等。然而，为了节省你的时间，`useFormik()` 返回一个名为 `formik.getFieldProps()` 的辅助方法，以便更快地连接输入。给定一些字段级的信息，它会返回给定字段的 `onChange`、`onBlur`、`value`、`checked` 的精确组。然后你可以在 `input`、`select` 或 `textarea` 上传播这些信息。

```js
import React from 'react'
import { useFormik } from 'formik'
import * as Yup from 'yup'

const SignupForm = () => {
  const formik = useFormik({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
    },
    validationSchema: Yup.object({
      firstName: Yup.string()
        .max(15, 'Must be 15 characters or less')
        .required('Required'),
      lastName: Yup.string()
        .max(20, 'Must be 20 characters or less')
        .required('Required'),
      email: Yup.string().email('Invalid email address').required('Required'),
    }),
    onSubmit: values => {
      alert(JSON.stringify(values, null, 2))
    },
  })
  return (
    <form onSubmit={formik.handleSubmit}>
      <label htmlFor='firstName'>First Name</label>
      <input
        id='firstName'
        type='text'
        {...formik.getFieldProps('firstName')}
      />
      {formik.touched.firstName && formik.errors.firstName ? (
        <div>{formik.errors.firstName}</div>
      ) : null}

      <label htmlFor='lastName'>Last Name</label>
      <input id='lastName' type='text' {...formik.getFieldProps('lastName')} />
      {formik.touched.lastName && formik.errors.lastName ? (
        <div>{formik.errors.lastName}</div>
      ) : null}

      <label htmlFor='email'>Email Address</label>
      <input id='email' type='email' {...formik.getFieldProps('email')} />
      {formik.touched.email && formik.errors.email ? (
        <div>{formik.errors.email}</div>
      ) : null}

      <button type='submit'>Submit</button>
    </form>
  )
}
```

### 利用 React Context

我们上面的代码再次非常明确地说明了 Formik 到底在做什么。`onChange` -> `handleChange`，`onBlur` -> `handleBlur`，等等。然而，我们仍然必须手动传递每个输入的 "参数获取器" `getFieldProps()`。为了节省你更多的时间，Formik 配备了 [React Context](https://reactjs.org/docs/context.html)-powered API/components，使生活更轻松，代码更不冗长。`<Formik />`, `<Form />`, `<Field />`, 和 `<ErrorMessage />`。更明确地说，它们隐含地使用 React Context 来连接父级的 `<Formik />` 状态/方法。

由于这些组件使用 React Context，我们需要渲染一个 [React Context Provider](https://reactjs.org/docs/context.html#contextprovider)，在我们的树中保存我们的表单状态和帮助器。如果你自己这样做，它看起来就像：

```js
import React from 'react'
import { useFormik } from 'formik'

// 创建空的 context
const FormikContext = React.createContext({})

// 将所有由 useFormik 返回的东西放入上下文中
export const Formik = ({ children, ...props }) => {
  const formikStateAndHelpers = useFormik(props)
  return (
    <FormikContext.Provider value={formikStateAndHelpers}>
      {typeof children === 'function'
        ? children(formikStateAndHelpers)
        : children}
    </FormikContext.Provider>
  )
}
```

幸运的是，我们已经在一个 `<Formik>` 组件中为你做了这个工作，就像这样。

现在让我们把 `useFormik()` hook 换成 Formik 的 `<Formik>` 组件/render-prop。由于它是一个组件，我们将把传递给 `useFormik()` 的对象转换为 JSX，每个键成为一个参数。

```js
import React from 'react'
import { Formik } from 'formik'
import * as Yup from 'yup'

const SignupForm = () => {
  return (
    <Formik
      initialValues={{ firstName: '', lastName: '', email: '' }}
      validationSchema={Yup.object({
        firstName: Yup.string()
          .max(15, 'Must be 15 characters or less')
          .required('Required'),
        lastName: Yup.string()
          .max(20, 'Must be 20 characters or less')
          .required('Required'),
        email: Yup.string().email('Invalid email address').required('Required'),
      })}
      onSubmit={(values, { setSubmitting }) => {
        setTimeout(() => {
          alert(JSON.stringify(values, null, 2))
          setSubmitting(false)
        }, 400)
      }}
    >
      {formik => (
        <form onSubmit={formik.handleSubmit}>
          <label htmlFor='firstName'>First Name</label>
          <input
            id='firstName'
            type='text'
            {...formik.getFieldProps('firstName')}
          />
          {formik.touched.firstName && formik.errors.firstName ? (
            <div>{formik.errors.firstName}</div>
          ) : null}

          <label htmlFor='lastName'>Last Name</label>
          <input
            id='lastName'
            type='text'
            {...formik.getFieldProps('lastName')}
          />
          {formik.touched.lastName && formik.errors.lastName ? (
            <div>{formik.errors.lastName}</div>
          ) : null}

          <label htmlFor='email'>Email Address</label>
          <input id='email' type='email' {...formik.getFieldProps('email')} />
          {formik.touched.email && formik.errors.email ? (
            <div>{formik.errors.email}</div>
          ) : null}

          <button type='submit'>Submit</button>
        </form>
      )}
    </Formik>
  )
}
```

正如你在上面看到的，我们换掉了 `useFormik()` hook，用 `<Formik>` 组件代替它。`<Formik>` 组件接受一个函数作为它的孩子（又称[渲染参数](https://reactjs.org/docs/render-props.html)）。它的参数与 `useFormik()` 返回的对象完全相同（事实上，`<Formik>` 在内部调用 `useFormik()`！）。因此，我们的表单和以前一样，只是现在我们可以使用新的组件以更简洁的方式来表达自己。

```js
import React from 'react'
import { Formik, Field, Form, ErrorMessage } from 'formik'
import * as Yup from 'yup'

const SignupForm = () => {
  return (
    <Formik
      initialValues={{ firstName: '', lastName: '', email: '' }}
      validationSchema={Yup.object({
        firstName: Yup.string()
          .max(15, 'Must be 15 characters or less')
          .required('Required'),
        lastName: Yup.string()
          .max(20, 'Must be 20 characters or less')
          .required('Required'),
        email: Yup.string().email('Invalid email address').required('Required'),
      })}
      onSubmit={(values, { setSubmitting }) => {
        setTimeout(() => {
          alert(JSON.stringify(values, null, 2))
          setSubmitting(false)
        }, 400)
      }}
    >
      <Form>
        <label htmlFor='firstName'>First Name</label>
        <Field name='firstName' type='text' />
        <ErrorMessage name='firstName' />

        <label htmlFor='lastName'>Last Name</label>
        <Field name='lastName' type='text' />
        <ErrorMessage name='lastName' />

        <label htmlFor='email'>Email Address</label>
        <Field name='email' type='email' />
        <ErrorMessage name='email' />

        <button type='submit'>Submit</button>
      </Form>
    </Formik>
  )
}
```

`<Field>` 组件默认会渲染一个 `<input>` 组件，给定一个 `name` 参数，会隐含地抓取相应的 `onChange`、`onBlur`、`value` 参数，并将它们传递给该元素以及你传递给它的任何参数。然而，由于不是所有的东西都是输入，`<Field>` 也接受一些其他的参数，让你呈现你想要的东西。一些例子……

```js
 // <input className="form-input" placeHolder="Jane"  />
 <Field name="firstName" className="form-input" placeholder="Jane" />

 // <textarea className="form-textarea"/></textarea>
 <Field name="message" as="textarea" className="form-textarea" />

 // <select className="my-select"/>
 <Field name="colors" as="select" className="my-select">
   <option value="red">Red</option>
   <option value="green">Green</option>
   <option value="blue">Blue</option>
 </Field>
```

React 是关于组合的，虽然我们已经减少了很多 [prop-drilling](https://kentcdodds.com/blog/prop-drilling)，但我们仍然在重复自己的工作，为我们的每个输入设置 `label`、`<Field>` 和 `<ErrorMessage>`。我们可以用抽象的方式做得更好!使用 Formik，你可以而且应该建立可重复使用的输入原始组件，在你的应用程序中共享。原来我们的 `<Field>` render-prop 组件有一个姐妹，她的名字是 `useField`，它将做同样的事情，但是通过 React Hooks！看看这个……

```js
import React from 'react'
import ReactDOM from 'react-dom'
import { Formik, Form, useField } from 'formik'
import * as Yup from 'yup'

const MyTextInput = ({ label, ...props }) => {
  // useField() 返回 [formik.getFieldProps(), formik.getFieldMeta()]
  // 我们可以在 <input> 上传播。我们可以使用字段元来显示错误信息，如果该字段是无效的，并且它已经被触及（即被访问）。
  const [field, meta] = useField(props)
  return (
    <>
      <label htmlFor={props.id || props.name}>{label}</label>
      <input className='text-input' {...field} {...props} />
      {meta.touched && meta.error ? (
        <div className='error'>{meta.error}</div>
      ) : null}
    </>
  )
}

const MyCheckbox = ({ children, ...props }) => {
  // React 对单选框和复选框输入的处理与其他输入类型、选择和文本框不同。
  // Formik 也会这样做!当你在 useField() 中指定 `type` 时，它将为你返回正确的参数包——一个 `checked` 参数将与 `name`、`value`、`onChange` 和 `onBlur` 一起包括在 `field` 中。
  const [field, meta] = useField({ ...props, type: 'checkbox' })
  return (
    <div>
      <label className='checkbox-input'>
        <input type='checkbox' {...field} {...props} />
        {children}
      </label>
      {meta.touched && meta.error ? (
        <div className='error'>{meta.error}</div>
      ) : null}
    </div>
  )
}

const MySelect = ({ label, ...props }) => {
  const [field, meta] = useField(props)
  return (
    <div>
      <label htmlFor={props.id || props.name}>{label}</label>
      <select {...field} {...props} />
      {meta.touched && meta.error ? (
        <div className='error'>{meta.error}</div>
      ) : null}
    </div>
  )
}

// 而现在我们可以使用这些
const SignupForm = () => {
  return (
    <>
      <h1>Subscribe!</h1>
      <Formik
        initialValues={{
          firstName: '',
          lastName: '',
          email: '',
          acceptedTerms: false, // 为我们的复选框添加的
          jobType: '', // 为我们的选择添加的
        }}
        validationSchema={Yup.object({
          firstName: Yup.string()
            .max(15, 'Must be 15 characters or less')
            .required('Required'),
          lastName: Yup.string()
            .max(20, 'Must be 20 characters or less')
            .required('Required'),
          email: Yup.string()
            .email('Invalid email address')
            .required('Required'),
          acceptedTerms: Yup.boolean()
            .required('Required')
            .oneOf([true], 'You must accept the terms and conditions.'),
          jobType: Yup.string()
            .oneOf(
              ['designer', 'development', 'product', 'other'],
              'Invalid Job Type'
            )
            .required('Required'),
        })}
        onSubmit={(values, { setSubmitting }) => {
          setTimeout(() => {
            alert(JSON.stringify(values, null, 2))
            setSubmitting(false)
          }, 400)
        }}
      >
        <Form>
          <MyTextInput
            label='First Name'
            name='firstName'
            type='text'
            placeholder='Jane'
          />

          <MyTextInput
            label='Last Name'
            name='lastName'
            type='text'
            placeholder='Doe'
          />

          <MyTextInput
            label='Email Address'
            name='email'
            type='email'
            placeholder='jane@formik.com'
          />

          <MySelect label='Job Type' name='jobType'>
            <option value=''>Select a job type</option>
            <option value='designer'>Designer</option>
            <option value='development'>Developer</option>
            <option value='product'>Product Manager</option>
            <option value='other'>Other</option>
          </MySelect>

          <MyCheckbox name='acceptedTerms'>
            I accept the terms and conditions
          </MyCheckbox>

          <button type='submit'>Submit</button>
        </Form>
      </Formik>
    </>
  )
}
```

正如你在上面看到的，`useField()` 给了我们将任何种类的 React 组件的输入连接到 Formik 的能力，就像它是一个 `<Field>`+`<ErrorMessage>`。我们可以用它来建立一组可重复使用的输入，以满足我们的需要。

## 结束语

祝贺你!你已经用 Formik 创建了一个注册表单：

- 具有复杂的验证逻辑和丰富的错误信息
- 在正确的时间向用户正确地显示错误信息（在他们模糊了一个字段之后）。
- 利用你自己的自定义输入组件，你可以在你的应用程序中的其他表格上使用。

干得好!我们希望你现在觉得你已经很好地掌握了 Formik 的运作方式。

在此查看最终结果：[最终结果](https://codesandbox.io/s/formik-v2-tutorial-final-ge1pt)。

如果你有额外的时间或想练习你的新 Formik 技能，这里有一些改进的想法，你可以对报名表进行改进，这些改进按难度的大小排列：

- 在用户试图提交时禁用提交按钮（暗示：`formik.isSubmitting`）
- 用 `formik.handleReset` 或 `<button type="reset">` 添加一个复位按钮。
- 根据 URL 查询字符串或传递给 `<SignupForm>` 的参数，预先填入 `initialValues`。
- 当一个字段有错误且未被关注时，将输入边框颜色改为红色
- 当每个字段显示错误并被访问时，为其添加抖动动画
- 将表单状态持久化到浏览器的 [sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) 中，以便在页面刷新之间保持表单的进展。

在整个教程中，我们触及了 Formik 的概念，包括表单状态、字段、验证、hooks、渲染参数和 React 上下文。对于这些主题的更详细的解释，请查看其余的[文档](https://formik.org/docs/tutorial)。要了解更多关于定义本教程中的组件和 hooks 的信息，请查看 [API 参考](https://formik.org/docs/tutorial)。
